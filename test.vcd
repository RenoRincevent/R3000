$date
  Wed Dec  4 08:59:41 2019
$end
$version
  GHDL v0
$end
$timescale
  1 fs
$end
$scope module standard $end
$upscope $end
$scope module textio $end
$upscope $end
$scope module std_logic_1164 $end
$upscope $end
$scope module numeric_std $end
$upscope $end
$scope module std_logic_arith $end
$upscope $end
$scope module bus_mux_pkg $end
$upscope $end
$scope module test $end
$var reg 32 ! a[31:0] $end
$var reg 32 " b[31:0] $end
$var reg 4 # sel[3:0] $end
$var reg 1 $ enable_v $end
$var reg 5 % valdec[4:0] $end
$var reg 1 & slt $end
$var reg 1 ' clk $end
$var reg 32 ( res[31:0] $end
$var reg 1 ) n $end
$var reg 1 * z $end
$var reg 1 + c $end
$var reg 1 , v $end
$scope module inst_alu $end
$var reg 32 - a[31:0] $end
$var reg 32 . b[31:0] $end
$var reg 4 / sel[3:0] $end
$var reg 1 0 enable_v $end
$var reg 5 1 valdec[4:0] $end
$var reg 1 2 slt $end
$var reg 1 3 clk $end
$var reg 32 4 res[31:0] $end
$var reg 1 5 n $end
$var reg 1 6 z $end
$var reg 1 7 c $end
$var reg 1 8 v $end
$var reg 32 9 s_and[31:0] $end
$var reg 32 : s_or[31:0] $end
$var reg 32 ; s_nor[31:0] $end
$var reg 32 < s_xor[31:0] $end
$var reg 1 = s_lr $end
$var reg 32 > s_bs[31:0] $end
$var reg 32 ? s_out_mux[31:0] $end
$var reg 32 @ s_out_adder[31:0] $end
$var reg 1 A flow $end
$var reg 1 B overflow $end
$var reg 1 C carry $end
$var reg 33 D locala[32:0] $end
$var reg 33 E localb[32:0] $end
$var reg 33 F localsum[32:0] $end
$var reg 33 G sumout[32:0] $end
$var reg 1 H res0 $end
$var reg 31 I tmp[30:0] $end
$var reg 32 J res0_vec[31:0] $end
$var reg 1 K ztmp $end
$scope module bs_inst $end
$var reg 32 L input[31:0] $end
$var reg 5 M shift_amount[4:0] $end
$var reg 1 N leftright $end
$var reg 1 O logicarith $end
$var reg 1 P shiftrotate $end
$var reg 32 Q output[31:0] $end
$upscope $end
$scope module mux_inst $end
$comment input is not handled $end
$var reg 3 R sel_input[2:0] $end
$var reg 32 S output[31:0] $end
$upscope $end
$scope module inst_reg0 $end
$var reg 1 T wr $end
$var reg 32 U data_in[31:0] $end
$var reg 32 V data_out[31:0] $end
$upscope $end
$scope module inst_reg1 $end
$var reg 1 W wr $end
$var reg 32 X data_in[31:0] $end
$var reg 32 Y data_out[31:0] $end
$upscope $end
$scope module inst_reg2 $end
$var reg 1 Z wr $end
$var reg 32 [ data_in[31:0] $end
$var reg 32 \ data_out[31:0] $end
$upscope $end
$scope module inst_reg3 $end
$var reg 1 ] wr $end
$var reg 32 ^ data_in[31:0] $end
$var reg 32 _ data_out[31:0] $end
$upscope $end
$upscope $end
$upscope $end
$enddefinitions $end
#0
b00000000000000000000000000001000 !
b00000000000000000000000000000010 "
b0000 #
0$
b00001 %
0&
0'
b00000000000000000000000000000000 (
U)
U*
U+
U,
b00000000000000000000000000001000 -
b00000000000000000000000000000010 .
b0000 /
00
b00001 1
02
03
b00000000000000000000000000000000 4
U5
U6
U7
U8
b00000000000000000000000000000000 9
b00000000000000000000000000001010 :
b11111111111111111111111111110101 ;
b00000000000000000000000000001010 <
1=
b00000000000000000000000000000001 >
b00000000000000000000000000000000 ?
b00000000000000000000000000001010 @
0A
0B
0C
b000000000000000000000000000001000 D
b000000000000000000000000000000010 E
b000000000000000000000000000001010 F
b000000000000000000000000000001010 G
0H
b0000000000000000000000000000000 I
b00000000000000000000000000000000 J
1K
b00000000000000000000000000000010 L
b00001 M
1N
0O
0P
b00000000000000000000000000000001 Q
b000 R
b00000000000000000000000000000000 S
0T
bUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUU0 U
bUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUU V
0W
bUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUU0 X
bUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUU Y
0Z
bUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUU0 [
bUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUU \
0]
bUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUU1 ^
bUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUUU _
#5000000
b0001 #
b00000000000000000000000000001010 (
b0001 /
b00000000000000000000000000001010 4
0=
b00000000000000000000000000000100 >
b00000000000000000000000000001010 ?
0N
b00000000000000000000000000000100 Q
b001 R
b00000000000000000000000000001010 S
#10000000
b0010 #
b0010 /
1=
b00000000000000000000000000000001 >
1N
b00000000000000000000000000000001 Q
b010 R
#15000000
b0011 #
b00000000000000000000000000000000 (
b0011 /
b00000000000000000000000000000000 4
0=
b00000000000000000000000000000100 >
b00000000000000000000000000000000 ?
0N
b00000000000000000000000000000100 Q
b011 R
b00000000000000000000000000000000 S
#20000000
b0100 #
b11111111111111111111111111110101 (
b0100 /
b11111111111111111111111111110101 4
1=
b00000000000000000000000000000001 >
b11111111111111111111111111110101 ?
1N
b00000000000000000000000000000001 Q
b100 R
b11111111111111111111111111110101 S
#25000000
b0101 #
b00000000000000000000000000001010 (
b0101 /
b00000000000000000000000000001010 4
0=
b00000000000000000000000000000100 >
b00000000000000000000000000001010 ?
0N
b00000000000000000000000000000100 Q
b101 R
b00000000000000000000000000001010 S
#30000000
b0110 #
b00000000000000000000000000000001 (
b0110 /
b00000000000000000000000000000001 4
1=
b00000000000000000000000000000001 >
b00000000000000000000000000000001 ?
1N
b00000000000000000000000000000001 Q
b110 R
b00000000000000000000000000000001 S
#35000000
b0111 #
b00000000000000000000000000000100 (
b0111 /
b00000000000000000000000000000100 4
0=
b00000000000000000000000000000100 >
b00000000000000000000000000000100 ?
0N
b00000000000000000000000000000100 Q
b111 R
b00000000000000000000000000000100 S
#40000000
